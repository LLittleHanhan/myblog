---
title: cpp oopBase
date: 2024-01-30 
tags: cpp
---


<!--more-->
## 访问控制
![](pic/oopbase-1.png)
![](pic/oopbase-2.png)

## 构造函数
先基后派生,基类若是无参构造（默认或自定义或缺省），初始化列表项可以不写基类
## 析构函数
>目前就我所知，就两种情况下必须写析构：1，类的成员数据里有不能自动释放的资源。比如Windows程序的HANDLE，Linux程序的file descriptor等等。2，你要写一个基类，期望用它来派生出各种子类。这时基类必须写虚析构函数，且至少必须有一个函数体，哪怕是空的。如果基类不写虚析构函数，则子类对象的析构有可能得不到调用，从而造成资源泄露。（这是因为如果你不写，则编译器会补上一个非虚析构函数，从而阻碍了晚绑定在析构函数上发生）如果基类写了虚析构函数，但是没写函数体，则连接器会报错。（这是因为子类的析构函数在最后会隐含的调用父类的析构函数，调用一个没有实现的函数会让连接器“找不到symbol”）3，还有一种情况，不能说必须写析构，但析构往往是一个很好的地方，用来做未尽之事宜。比如你写个全局配置信息类，构造时从某数据源（如配置文件、注册表、数据库等）读取配置，中途可以接受用户反复修改配置，那么析构可以用来将新配置信息写回数据源。再如你写个网络协议，设计一个类来代表会话，那么析构可以用来向对方发送一句拜拜。
## 拷贝构造
本质上就是构造函数，顺序基类->派生类内子对象->派生类
1. 派生类无自定义拷贝构造，则派生类使用默认拷贝构造，该拷贝构造会调用基类和子对象的拷贝构造，若基类或子对象无自定义的拷贝构造，则同样使用默认。。。依次迭代
2. 派生类有自定义的拷贝构造
   1. 若不在初始化列表指定，则默认调用基类和子对象的**无参构造函数**（默认或自定义或缺省），若没有则报错
   2. 在初始化列表指定`Derived(const Derived& rhs):Base(rhs),inobj(rhs.a)`这种是调用拷贝构造，或是指定构造，略
## 拷贝赋值

## override overload overwrite


## 多继承和虚基类
命名冲突问题
1. overwrite
2. using
3. 虚基类