---
title: cpp memory model
date: 2024-06-28
tags: cpp
---
cpp memory model
<!--more-->

## 事实
1. 由于硬件架构不同，一个程序在从高级语言开始经过编译，执行，仿存会产生多次乱序。
   1. 编译器只保证单个线程的执行结果是正确的
      1. 编译阶段的指令重排，交换无依赖的指令顺序  
      2. 编译阶段指令优化
   2. cpu指令乱序执行，考虑到rob，虽然是乱序执行，但是是顺序提交
   3. 提交的store指令不立即写回主存，而是存在store buffer，这种结构从当前线程角度看，访存顺序和提交顺序一致，从其他线程角度看，store buffer的提交顺序并不时rob指令的提交顺序
2. cpp提供了对底层的内存模型的抽象，从用户角度看，它是**宽松模型**，因为用户可以在此基础上添加屏障，之后由编译器翻译到对应架构上


## atomic

## fence

## volatile

## x86


1. 线程池
2. 22.34 内存屏障缓存行失效？
3. 50.0