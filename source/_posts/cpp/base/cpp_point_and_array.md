---
title: cpp point and array
date: 2024-01-30 
tags: cpp
---


<!--more-->
**首先明确几个问题**
## 数组指针 `int (*)[N]`
`int (*)[N] = int[N] *`
```c++
int (*a)[3];//指向长度为三的数组
int (*a)[3][4];//指向3*4的二维数组
```
## 查看变量类型
> typeinfo头文件里的typeid函数，这个函数或者说操作符是C++为支持RTTI（Run-Time Type Identification)运行时类型识别而提供的操作符之一，RTTI使程序能够获取由基指针或引用所指向的对象的实际派生类型，即允许“用指向基类的指针或引用来操作对象”的程序能够获取到“这些指针或引用所指对象”的实际派生类型。另外的操作符主要还有dynamic_cast和static_cast
```c++
#include<iostream>
#include <typeinfo>
using namespace std;

int main(){
    int a[3][4] ={{1,2,3,4},
                {1,2,3,4},
                {1,2,3,4},};
    int (*b)[3][4];
    int (*c)[4];
    int *d;
    int e;

    cout<<"&a: "<<&a<<"\tsizeof(&a): "<<sizeof(&a)<<"\ttypeof(&a): "<<typeid(&a).name()<<endl;
    cout<<"a: "<<a<<"\tsizeof(a): "<<sizeof(a)<<"\ttypeof(a): "<<typeid(a).name()<<endl;
    cout<<"&a[0]: "<<&a[0]<<"\tsizeof(&a[0]): "<<sizeof(&a[0])<<"\ttypeof(&a[0]): "<<typeid(&a[0]).name()<<endl;
    cout<<"a[0]: "<<a[0]<<"\tsizeof(a[0]): "<<sizeof(a[0])<<"\ttypeof(a[0]): "<<typeid(a[0]).name()<<endl;
    cout<<"&a[0][0]: "<<&a[0][0]<<"\tsizeof(&a[0][0]): "<<sizeof(&a[0][0])<<"\ttypeof(&a[0][0]): "<<typeid(&a[0][0]).name()<<endl;
    cout<<"a[0][0]: "<<a[0][0]<<"\tsizeof(a[0][0]): "<<sizeof(a[0][0])<<"\ttypeof(a[0][0]): "<<typeid(a[0][0]).name()<<endl;
   
    system("pause");
    return 0;
```
## 数组到指针的隐式转换
> 目前看到的都是说转换发生在参数传递时，且只转换一次
> 其他情况也能解释的通，就先这样理解

`int a[3][4]`
下表的变量名值相同但是类型不同！！！
|   变量名   |      类型       |     转换     |
| :--------: | :-------------: | :----------: |
|    `a`     |   `int[3][4]`   | `int (*)[4]` |
|    `&a`    | `int (*)[3][4]` |      -       |
|   `a[0]`   |    `int[4]`     |    `int*`    |
|  `&a[0]`   |  `int (*)[4]`   |      -       |
| `a[0][0]`  |      `int`      |      -       |
| `&a[0][0]` |     `int*`      |      -       |

## 数组的"粒度"
`int a[3];`
- `a[1] = *(a+1)` 这两者等价,a类型int*，是指向int的指针，所以a+1为**a的地址+4**

`int a[3][4];`
- `a[1] = *(a+1)` 由上表a类型int[3][4],可以隐式转换为int (*)[4],所以a+1为第二行首地址**a的地址+4*4**
- `(&a)[1] = *(&a+1)` 由上表&a的类型为int (*)[3][4],即粒度为整个二维数组


## 下标运算符
其实上一节已经使用了，这里就不详细写，注意数组粒度即可`a[1]=*(a+1)`
`int a[3][4]`
a[1][1]的索引过程
1. a的类型int[3][4],隐式转换后为int (*)[4]即行指针，粒度为一行
2. a[1][1]从左到右运算，a[1]=*(a+1)
3. a[1]的类型为int[4],再进行一次隐式转换为int*
4. (a[1])[1]就是一维数组索引，之后略

## 传参
以上，总结二维数组传参的方法
首先明确三个东西:
1. 参数值
2. 参数类型
3. 标识符

传的参数肯定都是一样的——首地址，不同的形式类型不一样，即指针粒度不同,以下是正常的方法
```c++
void f(int a[3][4]);
void f(int a[][4]);//这里第一维可以省略是因为索引计算时没用到
void f(int(*a)[4]);

int main(){
    int a[3][4];
    f(a);
}
```
以下的传参也可，分析一下
- 二维变一维，按一维索引
```c++
void f(int* a){
    a[i*4+j];
}
// main
f(a[0]);
f(&a[0][0]);
```
- 三维？注意行参是a，类型为int (*)[3][4]
```c++
void f(int (*a)[3][4]){
    a[0][i][j];
}
//main
f(&a);
```
**总结下来一句话，传的参数要和行参对应，因此要搞清楚传的东西到底是什么类型，看表！！！**

## 思考
二维数组和指针的指针有关系吗？
a：没啥关系，它们只是值一样，类型不一样，可以强制类型转换
```c++
int a[2][3];
int** p = 0;
p = (int**)a;
```